<!DOCTYPE html>
<html lang="en" class="bg-gray-950 text-white"> <!-- Added classes -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>String Art</title>
    <!-- Load Tailwind CSS -->
    
    <!-- Load Lucide Icons -->
    
    <style>
        /* Match index.html font style */
        html {
            font-family: sans-serif;
        }
        body {
            font-family: inherit; /* Inherit from html */
        }
        /* Custom styles for range sliders */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #374151; /* gray-700 */
            border-radius: 9999px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #ec4899; /* pink-500 */
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #ec4899; /* pink-500 */
            border-radius: 50%;
            cursor: pointer;
        }
        /* Custom styles for select dropdowns */
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-position: right 0.75rem center;
            background-repeat: no-repeat;
            background-size: 1.25em 1.25em;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
        }
    </style>
</head>
<!-- Updated body classes -->
<body hidden class="bg-gray-950 text-gray-200 flex flex-col items-center min-h-screen p-4">

    <!-- Navigation Bar - Matched index.html colors -->
    <site-nav></site-nav>

    <div class="w-full max-w-5xl p-4">
        
        <!-- Header -->
        <h1 class="text-3xl font-bold text-center mb-2 text-pink-400">String Art</h1>
        <p class="text-center text-gray-400 mb-6">Now with shape and color generators!</p>

        <!-- Controls - Matched index.html colors -->
        <div class="bg-gray-900 p-6 rounded-2xl shadow-xl mb-6 grid grid-cols-1 md:grid-cols-3 gap-6">
            
            <!-- Points Slider -->
            <div class="space-y-2">
                <div class="flex justify-between items-center">
                    <label for="pointsSlider" class="font-medium">Points</label>
                    <span id="pointsValue" class="text-pink-400 font-mono text-sm">200</span>
                </div>
                <input type="range" id="pointsSlider" min="10" max="500" value="200" step="1">
            </div>

            <!-- Multiplier Slider -->
            <div class="space-y-2">
                <div class="flex justify-between items-center">
                    <label for="multiplierSlider" class="font-medium">Multiplier</label>
                    <span id="multiplierValue" class="text-pink-400 font-mono text-sm">2</span>
                </div>
                <input type="range" id="multiplierSlider" min="2" max="150" value="2" step="0.1">
            </div>
            
            <!-- Opacity Slider -->
            <div class="space-y-2">
                <div class="flex justify-between items-center">
                    <label for="opacitySlider" class="font-medium">Line Opacity</label>
                    <span id="opacityValue" class="text-pink-400 font-mono text-sm">0.1</span>
                </div>
                <input type="range" id="opacitySlider" min="0.01" max="1" value="0.1" step="0.01">
            </div>

            <!-- Shape Selector -->
            <div class="space-y-2">
                <label for="shapeSelect" class="font-medium">Shape</label>
                <select id="shapeSelect" class="w-full p-2 bg-gray-800 border border-gray-700 rounded-lg text-gray-200 focus:outline-none focus:ring-2 focus:ring-pink-500"> <!-- Darker bg -->
                    <option value="circle" selected>Circle</option>
                    <option value="oval">Oval</option>
                    <option value="square">Square</option>
                    <option value="triangle">Triangle</option>
                </select>
            </div>

            <!-- Color Mode Selector -->
            <div class="space-y-2">
                <label for="colorModeSelect" class="font-medium">Color Mode</label>
                <select id="colorModeSelect" class="w-full p-2 bg-gray-800 border border-gray-700 rounded-lg text-gray-200 focus:outline-none focus:ring-2 focus:ring-pink-500"> <!-- Darker bg -->
                    <option value="single" selected>Single Color</option>
                    <option value="spectrum">Spectrum</option>
                    <option value="fire">Fire (Red/Yellow)</option>
                    <option value="ocean">Ocean (Green/Blue)</option>
                </select>
            </div>

            <!-- Hue Slider (for Single Color) -->
            <div id="hueControlContainer" class="space-y-2">
                <div class="flex justify-between items-center">
                    <label for="hueSlider" class="font-medium">Color Hue</label>
                    <span id="hueValue" class="text-pink-400 font-mono text-sm">180</span>
                </div>
                <input type="range" id="hueSlider" min="0" max="360" value="180" step="1">
            </div>

        </div> <!-- Closed the controls div -->

        <!-- Canvas Container - Matched index.html colors -->
        <div class="w-full aspect-square bg-gray-900 rounded-2xl shadow-xl overflow-hidden">
            <canvas id="stringArtCanvas"></canvas>
        </div>

        <!-- About Card - Matched index.html colors -->
        <div class="bg-gray-900 p-6 rounded-2xl shadow-xl mt-6">
            <h2 class="text-2xl font-bold text-pink-400 mb-3">About the Inspiration: John Eichinger</h2>
            <p class="text-gray-300 leading-relaxed">
                This style of art was heavily popularized in the 1960s and 70s by artist John Eichinger. He specialized in these geometric designs, coining the term string mandala. His work was famously marketed through Open Door Enterprises, which distributed hobby craft kits that brought this unique blend of math and art into homes across the US.
            </p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('stringArtCanvas');
        const ctx = canvas.getContext('2d');

        // Get control elements
        const pointsSlider = document.getElementById('pointsSlider');
        const multiplierSlider = document.getElementById('multiplierSlider');
        const hueSlider = document.getElementById('hueSlider');
        const opacitySlider = document.getElementById('opacitySlider');
        const shapeSelect = document.getElementById('shapeSelect');
        const colorModeSelect = document.getElementById('colorModeSelect');
        const hueControlContainer = document.getElementById('hueControlContainer');

        // Get value display elements
        const pointsValue = document.getElementById('pointsValue');
        const multiplierValue = document.getElementById('multiplierValue');
        const hueValue = document.getElementById('hueValue');
        const opacityValue = document.getElementById('opacityValue');

        // Helper: Linear Interpolation
        const lerp = (a, b, t) => a + (b - a) * t;

        // Helper: Generate points for a shape
        function generatePoints(shape, numPoints, cx, cy, radius) {
            const points = [];
            const addPointsOnLine = (v1, v2, num) => {
                for (let i = 0; i < num; i++) {
                    const t = num === 1 ? 0.5 : i / (num - 1);
                    points.push({
                        x: lerp(v1.x, v2.x, t),
                        y: lerp(v1.y, v2.y, t)
                    });
                }
            };

            switch (shape) {
                case 'circle':
                    for (let i = 0; i < numPoints; i++) {
                        const angle = (i / numPoints) * 2 * Math.PI - Math.PI / 2;
                        points.push({
                            x: cx + radius * Math.cos(angle),
                            y: cy + radius * Math.sin(angle)
                        });
                    }
                    break;
                case 'oval':
                    for (let i = 0; i < numPoints; i++) {
                        const angle = (i / numPoints) * 2 * Math.PI - Math.PI / 2;
                        points.push({
                            x: cx + (radius * 1.3) * Math.cos(angle), // Wider
                            y: cy + (radius * 0.8) * Math.sin(angle)  // Shorter
                        });
                    }
                    break;
                case 'square':
                    const r = radius;
                    const v = [
                        { x: cx - r, y: cy - r }, // Top-left
                        { x: cx + r, y: cy - r }, // Top-right
                        { x: cx + r, y: cy + r }, // Bottom-right
                        { x: cx - r, y: cy + r }  // Bottom-left
                    ];
                    const pps = Math.floor(numPoints / 4);
                    addPointsOnLine(v[0], v[1], pps);
                    addPointsOnLine(v[1], v[2], pps);
                    addPointsOnLine(v[2], v[3], pps);
                    addPointsOnLine(v[3], v[0], numPoints - (3 * pps)); // Remainder
                    break;
                case 'triangle':
                    const v_tri = [
                        { x: cx, y: cy - radius }, // Top
                        { x: cx + radius * 0.866, y: cy + radius * 0.5 }, // Bottom-right
                        { x: cx - radius * 0.866, y: cy + radius * 0.5 }  // Bottom-left
                    ];
                    const pps_tri = Math.floor(numPoints / 3);
                    addPointsOnLine(v_tri[0], v_tri[1], pps_tri);
                    addPointsOnLine(v_tri[1], v_tri[2], pps_tri);
                    addPointsOnLine(v_tri[2], v_tri[0], numPoints - (2 * pps_tri)); // Remainder
                    break;
            }
            return points;
        }

        // Main draw function
        function draw() {
            if (!ctx) return;

            // Get current values
            const numPoints = parseInt(pointsSlider.value);
            const multiplier = parseFloat(multiplierSlider.value);
            const baseHue = parseInt(hueSlider.value);
            const opacity = parseFloat(opacitySlider.value);
            const shape = shapeSelect.value;
            const colorMode = colorModeSelect.value;

            // Update display values
            pointsValue.textContent = numPoints;
            multiplierValue.textContent = multiplier.toFixed(1);
            hueValue.textContent = baseHue;
            opacityValue.textContent = opacity.toFixed(2);
            
            // Show/hide hue slider
            if (colorMode === 'single') {
                hueControlContainer.style.display = 'block';
            } else {
                hueControlContainer.style.display = 'none';
            }

            // Set canvas size
            const size = canvas.parentElement.clientWidth;
            canvas.width = size;
            canvas.height = size;

            // Clear canvas with background color
            ctx.fillStyle = 'rgb(17, 24, 39)'; // bg-gray-900
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) * 0.9;

            // Generate all points on the selected shape
            const points = generatePoints(shape, numPoints, centerX, centerY, radius);
            const actualNumPoints = points.length; // Use actual points generated

            if (actualNumPoints === 0) return;

            ctx.lineWidth = 1;

            // We must draw line by line to support changing colors
            for (let i = 0; i < actualNumPoints; i++) {
                const p1 = points[i];
                
                // Calculate the target point index
                const targetIndex = Math.floor(i * multiplier) % actualNumPoints;
                const p2 = points[targetIndex];

                // Calculate current line's hue
                let currentHue = 0;
                const progress = i / actualNumPoints;

                switch (colorMode) {
                    case 'single':
                        currentHue = baseHue;
                        break;
                    case 'spectrum':
                        currentHue = progress * 360;
                        break;
                    case 'fire':
                        currentHue = 60 * progress; // 0 (Red) to 60 (Yellow)
                        break;
                    case 'ocean':
                        currentHue = 160 + (80 * progress); // 160 (Green) to 240 (Blue)
                        break;
                }

                // Set line style for this specific line
                ctx.strokeStyle = `hsla(${currentHue}, 80%, 70%, ${opacity})`;
                
                // Draw the line
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }
        }

        // --- Event Listeners ---

        // Redraw when any control is changed
        [pointsSlider, multiplierSlider, hueSlider, opacitySlider, shapeSelect, colorModeSelect].forEach(control => {
            control.addEventListener('input', draw);
        });

        // Handle window resize
        let resizeTimer;
        window.addEventListener('resize', () => {
            // Debounce resize event
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(draw, 100);
        });

        // Initial draw on window load
        // This ensures the layout is calculated before we get the canvas size
        window.onload = () => {
            // Add a small delay to ensure layout is fully settled
            setTimeout(draw, 50); 
        };
    </script>

    <!-- Script for Nav Bar Icons and Dropdowns -->
    
<script type="module" src="/main.js"></script>
</body>
</html>